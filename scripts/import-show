#!/usr/bin/env python3
"""Rename TV show files to standard SXXEXX format."""

from __future__ import annotations

import argparse
import re
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Generic, TypeVar


class Id:
    """File identifier."""


@dataclass(frozen=True, order=True)
class PartialId(Id):
    """Partial file identifier."""

    episode: int

    def __str__(self) -> str:
        return f"EP{self.episode:02d}"

    class Format(Enum):
        EP = re.compile(r"ep.?(\d+)")
        EPISODE = re.compile(r"episode.?(\d+)")
        FIRST_NUMBER = re.compile(r"(\d+)")
        SECOND_NUMBER = re.compile(r"\d+.*?(\d+)")
        THIRD_NUMBER = re.compile(r"\d+.*?\d+.*?(\d+)")
        FOURTH_NUMBER = re.compile(r"\d+.*?\d+.*?\d+.*?(\d+)")


@dataclass(frozen=True, order=True)
class CompleteId(Id):
    """Complete file identifier."""

    season: int
    episode: int

    def __str__(self) -> str:
        return f"S{self.season:02d}E{self.episode:02d}"

    class Format(Enum):
        SXXEXX = re.compile(r"s(\d+)e(\d+)", re.IGNORECASE)
        SEASON_EPISODE = re.compile(r"season\s*(\d+)\s*episode\s*(\d+)", re.IGNORECASE)


T = TypeVar("T", bound=Id)


class IdMap(Generic[T]):
    def get_keys(self) -> list[T]: ...

    def get(self, id_: T) -> Path: ...


class PartialIdMap(IdMap[PartialId]):
    def __init__(self) -> None:
        self._paths: dict[PartialId, Path] = {}

    def get_keys(self) -> list[PartialId]:
        return list(self._paths.keys())

    def get(self, id_: PartialId) -> Path:
        return self._paths[id_]

    def add(self, id_: PartialId, path: Path) -> None:
        self._paths[id_] = path

    def has(self, id_: PartialId) -> bool:
        return id_ in self._paths

    def to_complete(self, season: int) -> CompleteIdMap:
        completed_id_map = CompleteIdMap()
        for id_, path in self._paths.items():
            completed_id = CompleteId(season=season, episode=id_.episode)
            completed_id_map.add(completed_id, path)
        return completed_id_map


class CompleteIdMap(IdMap[CompleteId]):
    def __init__(self) -> None:
        self._paths: dict[CompleteId, Path] = {}

    def get_keys(self) -> list[CompleteId]:
        return list(self._paths.keys())

    def get(self, id_: CompleteId) -> Path:
        return self._paths[id_]

    def add(self, id_: CompleteId, path: Path) -> None:
        self._paths[id_] = path

    def has(self, id_: CompleteId) -> bool:
        return id_ in self._paths


def get_partial_id_map(
    files: list[Path], format_: PartialId.Format,
) -> PartialIdMap | None:
    partial_id_map = PartialIdMap()
    for file in files:
        if (match := format_.value.search(file.stem)) is None:
            return None
        episode = int(match.group(1))
        id_ = PartialId(episode=episode)

        if partial_id_map.has(id_):
            return None

        partial_id_map.add(id_, file)

    return partial_id_map


def get_complete_id_map(
    files: list[Path], format_: CompleteId.Format,
) -> CompleteIdMap | None:
    complete_id_map = CompleteIdMap()
    for file in files:
        if (match := format_.value.search(file.stem)) is None:
            return None
        season, episode = map(int, match.groups())
        id_ = CompleteId(season=season, episode=episode)

        if complete_id_map.has(id_):
            return None

        complete_id_map.add(id_, file)

    return complete_id_map


def main(source: Path, target: Path, *, update: bool) -> None:
    """Link TV show files with standardized names."""
    files = [f for f in source.glob("*") if f.is_file()]

    if len(files) == 0:
        msg = f"No files found in {source}"
        raise SystemExit(msg)

    for complete_id_format in CompleteId.Format:
        if (complete_id_map := get_complete_id_map(files, complete_id_format)) is None:
            continue

        if not is_format_confirmed(complete_id_format.name, complete_id_map):
            continue

        write(complete_id_map, target, update=update)
        raise SystemExit

    for partial_id_format in PartialId.Format:
        if (partial_id_map := get_partial_id_map(files, partial_id_format)) is None:
            continue

        if not is_format_confirmed(partial_id_format.name, partial_id_map):
            continue

        season = int(input("\nPlease input season number: "))
        completed_id_map = partial_id_map.to_complete(season)

        # TODO: Maybe add a guardrail not to write immediately after inputting something
        write(completed_id_map, target, update=update)
        raise SystemExit

    msg = "No suitable format found"
    raise SystemExit(msg)


def is_format_confirmed(format_name: str, id_map: IdMap) -> bool:
    print(f"Detected format: {format_name}")
    for id_ in sorted(id_map.get_keys()):
        file = id_map.get(id_)
        print(f"- {id_}: {file.name}")

    return input("\nProceed? [Y/n] ").strip().lower() != "n"


def write(id_map: IdMap[CompleteId], target: Path, *, update: bool) -> None:
    if not update:
        target.mkdir()

    ids = id_map.get_keys()

    for id_ in ids:
        file = id_map.get(id_)
        target_file = target / f"{id_}{file.suffix}"
        target_file.hardlink_to(file)

    print(f"\nLinked {len(ids)} files to {target}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("source", type=Path)
    parser.add_argument("target", type=Path)
    parser.add_argument(
        "--update",
        action="store_true",
        help="Create target directory (error if exists)",
    )
    args = parser.parse_args()

    main(source=args.source, target=args.target, update=args.update)
