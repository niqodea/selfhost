#!/usr/bin/env python3
"""Rename TV show files to standard SXXEXX format."""

from __future__ import annotations

import argparse
import re
from dataclasses import dataclass
from enum import Enum
from pathlib import Path


@dataclass(frozen=True, order=True)
class Id:
    """Complete file identifier with season and episode numbers."""

    season: int
    episode: int

    def __str__(self) -> str:
        return f"S{self.season:02d}E{self.episode:02d}"


class CompleteFormat(Enum):
    """Supported formats for season and episode info."""

    SXXEXX = re.compile(r"s(\d+)e(\d+)", re.IGNORECASE)
    SEASON_EPISODE = re.compile(r"season\s*(\d+)\s*episode\s*(\d+)", re.IGNORECASE)


class PartialFormat(Enum):
    """Supported formats for episode info only."""

    E_XX = re.compile(r"e[-_\.\s]?(\d+)", re.IGNORECASE)
    EP_XX = re.compile(r"ep[-_\.\s]?(\d+)", re.IGNORECASE)
    EPISODE_XX = re.compile(r"episode[-_\.\s]?(\d+)", re.IGNORECASE)
    FIRST_NUMBER = re.compile(r"(\d+)", re.IGNORECASE)
    SECOND_NUMBER = re.compile(r"\d+.*?(\d+)", re.IGNORECASE)
    THIRD_NUMBER = re.compile(r"\d+.*?\d+.*?(\d+)", re.IGNORECASE)
    FOURTH_NUMBER = re.compile(r"\d+.*?\d+.*?\d+.*?(\d+)", re.IGNORECASE)


def main(
    source: Path, target: Path, assumed_season: int | None, *, update: bool,
) -> None:
    """Link TV show files with standardized names."""
    files = [f for f in source.glob("*") if f.is_file()]

    if len(files) == 0:
        msg = f"No files found in {source}"
        raise SystemExit(msg)

    if assumed_season is None:
        id_map = apply_complete_formats(files)
    else:
        id_map = apply_partial_formats(files, assumed_season)

    if id_map is None:
        msg = "No suitable format found"
        raise SystemExit(msg)

    if not update:
        target.mkdir()

    for id_, file in id_map.items():
        target_file = target / f"{id_}{file.suffix}"
        target_file.hardlink_to(file)

    print(f"\nLinked {len(id_map)} files to {target}")


def apply_complete_formats(files: list[Path]) -> dict[Id, Path] | None:
    for complete_format in CompleteFormat:
        if (id_map := apply_complete_format(complete_format, files)) is None:
            continue

        if not is_id_map_confirmed(complete_format.name, id_map):
            continue

        return id_map
    return None


def apply_complete_format(
    format_: CompleteFormat,
    files: list[Path],
) -> dict[Id, Path] | None:
    """Use the given complete format to extract ids from files."""
    id_map: dict[Id, Path] = {}
    for file in files:
        if (match := format_.value.search(file.stem)) is None:
            return None
        season, episode = map(int, match.groups())
        id_ = Id(season=season, episode=episode)

        if id_ in id_map:
            return None

        id_map[id_] = file

    return id_map


def apply_partial_formats(
    files: list[Path], assumed_season: int,
) -> dict[Id, Path] | None:
    for partial_format in PartialFormat:
        if (
            id_map := apply_partial_format(partial_format, assumed_season, files)
        ) is None:
            continue

        if not is_id_map_confirmed(partial_format.name, id_map):
            continue

        return id_map
    return None


def apply_partial_format(
    format_: PartialFormat,
    season: int,
    files: list[Path],
) -> dict[Id, Path]:
    """Use the given partial format and season to extract ids from files."""
    id_map: dict[Id, Path] = {}
    for file in files:
        if (match := format_.value.search(file.stem)) is None:
            return None
        episode = int(match.group(1))
        id_ = Id(season=season, episode=episode)

        if id_ in id_map:
            return None

        id_map[id_] = file

    return id_map


def is_id_map_confirmed(format_name: str, id_map: dict[Id, Path]) -> bool:
    """Display detected file ids and prompt for confirmation."""
    print(f"Detected format: {format_name}")
    for id_, file in sorted(id_map.items()):
        print(f"- {id_}: {file.name}")

    return input("\nProceed? [y/N] ").strip().lower() == "y"


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("source", type=Path)
    parser.add_argument("target", type=Path)
    parser.add_argument("--assumed-season", type=int)
    parser.add_argument(
        "--update",
        action="store_true",
        help="Update existing target directory",
    )
    args = parser.parse_args()

    main(
        source=args.source,
        target=args.target,
        assumed_season=args.assumed_season,
        update=args.update,
    )
